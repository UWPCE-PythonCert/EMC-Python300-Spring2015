<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=1024, user-scalable=no">

  <title>Python300 week 05, Serialization and XML</title>

  <!-- Required stylesheet -->
  <link rel="stylesheet" media="screen" href="core/deck.core.css">

  <!-- Extension CSS files go here. Remove or add as needed. -->
  <link rel="stylesheet" media="screen" href="extensions/goto/deck.goto.css">
  <link rel="stylesheet" media="screen" href="extensions/menu/deck.menu.css">
  <link rel="stylesheet" media="screen" href="extensions/navigation/deck.navigation.css">
  <link rel="stylesheet" media="screen" href="extensions/status/deck.status.css">
  <link rel="stylesheet" media="screen" href="extensions/scale/deck.scale.css">

  <!-- Style theme. More available in /themes/style/ or create your own. -->
  <link rel="stylesheet" media="screen" href="themes/style/swiss.css">
  <!-- Transition theme. More available in /themes/transition/ or create your own. -->
  <link rel="stylesheet" media="screen" href="themes/transition/horizontal-slide.css">

  <!-- Basic black and white print styles -->
  <link rel="stylesheet" media="print" href="core/print.css">

  <!-- Required Modernizr file -->
  <script src="modernizr.custom.js"></script>
</head>
<body>
  <div class="deck-container">

    <!-- Begin slides. Just make elements with a class of slide. -->
    <section class="slide">
        <h2>System Development with Python</h2>
        <h3>Week 5 :: XML</h3>
    </section>

<section class="slide">
    <h2>Today's topics</h2>
    <ul>
        <li>Python XML libs
    </ul>
</section>

<section class="slide">
    <h2>XML</h2>
    <p>Extensible Markup Language (XML) defines a set of rules for encoding documents in a format that is both human- and machine-readable.
    <p>It's been around since about 1996, so all major platforms have good support
    <p>Has robust validation frameworks: Document Type Definition (DTD) and XML Schema Definition (XSD)
    <p>Subject to <a target="_blank" href="http://docs.python.org/2/library/xml.html#xml-vulnerabilities">vulnerabilities</a>.  (<a target="_blank" href="http://en.wikipedia.org/wiki/Billion_laughs">For example</a> examples/billion_lolz.py)

</section>

<section class="slide">
    <h2>Wikipedia example</h2>
    <p>In the repository you'll find a random portion of the wikipedia database, found in examples/data/enwiki-latest-pages-articles1.xml-p000000010p000010000-shortened.bz2
    <p>Original source is here <a href="http://dumps.wikimedia.org/enwiki/latest/enwiki-latest-pages-articles1.xml-p000000010p000010000.bz2">
    http://dumps.wikimedia.org/enwiki/latest/enwiki-latest-pages-articles1.xml-p000000010p000010000.bz2</a>, but it's pretty big so we'll just use a subset of it.
    </p>
    <p>We'll parse this using several of the tools presented.
</section>

<section class="slide">
    <h2>SAX versus DOM</h2>
    <h3>SAX - Simple API for XML</h3>
    <ul>
        <li>Event based stream processing
        <li>Document is processed element by element, so it is efficient for large documents
        <li>You have to keep track of location in the tree, bookkeeping gets tricky
        <li>Not efficient for random access
        <li>Can't insert or delete nodes
    </ul>

    <h3>DOM - Document Object Model</h3>
    <ul>
        <li>Easy to find elements with DOM methods, XPath, etc.
        <li>More efficient for random access
        <li>Docment is usually stored in memory, so not suitable for large documents
        <li>Can insert and delete nodes
    </ul>
</section>

<section class="slide">
    <h2><a target="_blank" href="https://docs.python.org/2/library/xml.sax.html">xml.sax</a> </h2>
    <p>The xml.sax package provides a number of modules which implement the Simple API for XML (SAX) interface for Python
    <p>A SAX application has three kinds of objects: readers, handlers, and input sources
    <ul>
        <li>Input sources provide the raw stream of XML bytes from a source such as a file or the network
        <li>Readers, also known as parsers, parse the stream into elements and generate events
        <li>Handlers handle the events generated by the reader to do useful work
    </ul>
</section>

<section class="slide">
    <h2>Handling SAX events</h2>
    <p>xml.sax.handler defines 4 kinds of handlers:
        <ul>
            <li>content handlers
            <li>DTD handlers
            <li>error handlers
            <li>entity resolvers
        </ul>
    <p>The most important handler for getting your job done is <a target="_blank" href="https://docs.python.org/2/library/xml.sax.handler.html#contenthandler-objects">xml.sax.handler.ContentHandler</a>
    <p>To create your handler, just subclass ContentHandler
    <p>3 methods are necessary to override in order to get element data:
    <ul>
        <li>ContentHandler.startElement(name, attrs)
        <li>ContentHandler.endElement(name)
        <li>ContentHandler.characters(content) - returns a chunk of character data, which may be all contiguous character data in one chunk (string), or split into more than one chunk
    </ul>
</section>

<section class="slide">
    <h2>wikipedia-sax.py</h2>
    <p>examples/wikipedia-sax.py creates a handler which logs the content of every &lt;title&gt; tag it encounters
    <p>Try running this to make sure it works
    <p class="slide">Now it's your turn.
        <ul class="slide">
            <li>The data consists of &lt;page&gt; elements for each page.
            <li>The current revision's author is stored as page/revision/contributor/username.
            <ol>
            <li>Modify wikipedia-sax.py to log every username tag 
            <li>How can we list the username with the most contributions in this data after the document is done parsing?
            </ol>
        </ul>
    </p>
</section>

<section class="slide">
    <h2><a target="_blank" href="https://docs.python.org/2/library/xml.dom.html#module-xml.dom">xml.dom</a> </h2>
    <p>The xml.dom package provides a number of modules which implement the Document Object Model API
    <p>A reference implementation is in <a target="_blank" href="https://docs.python.org/2/library/xml.dom.minidom.html#module-xml.dom.minidom">xml.dom.minidom</a> - Minimal DOM implementation
    <!--<p>For creating partial documents there is <a target="_blank" href="https://docs.python.org/2/library/xml.dom.pulldom.html">xml.dom.pulldom</a>-->
    <p>DOM is an <a target="_blank" href="http://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html">RFC standard</a> which minidom implements.   If you've done DOM manipulation in Javascript, the methods will be familiar: createElement, getElementsByTagName, appendChild, ..
</section>

<section class="slide">
    <h2>xml.dom.minidom</h2>
    <p>To get a reference to a Document object for your XML, just pass it to one of the parse methods:
    <ul>
    <li>xml.dom.minidom.parse(filename_or_file[, parser[, bufsize]])
    <li>xml.dom.minidom.parseString(string[, parser])
    </ul>
    <p>The optional parser argument is for passing a SAX2 parser object
    <p>You can also create a Document from scratch by calling a method on a "DOM Implementation" object:

<pre><code>from xml.dom.minidom import getDOMImplementation

impl = getDOMImplementation()

newdoc = impl.createDocument(None, "some_tag", None)
top_element = newdoc.documentElement
text = newdoc.createTextNode('Some textual content.')
top_element.appendChild(text)
</code></pre>
</section>

<section class="slide">
    <h2>manipulating the DOM</h2>
    <img width="80%" src="img/nodetree.gif" />
    <p>Duplicate a node with node.cloneNode(deep) # True or False to specify a deep or shallow copy
    <p>Get a reference to a node's parent with node.parentNode
    <p>append a node to another with node.appendChild(element)
    <p>Create a new node with document.createElement('elementname')
</section>

<section class="slide">
    <h2>wikipedia-minidom.py</h2>
    <p>examples/wikipedia-minidom.py reads a Document, then logs the content of every &lt;title&gt; tag it encounters
    <p>Try running this to make sure it works
    <p class="slide">Now it's your turn.
        <ul class="slide">
            <li>The data consists of &lt;page&gt; elements for each page.
            <li>Modify wikipedia-minidom.py to create a new last page which is a copy of the existing last page
            <li>Add a new element, &lt;modifiedby&gt; containing your superhero name to your new page element
            <li>Useful properties and methods may include those on the previous page: parentNode, cloneNode, appendChild, createElement
            <li>You can output a human readable version with the method document.toprettyxml.   The encoding kwarg may be helpful.
        </ul>
    </p>
</section>


<section class="slide">
    <h2><a target="_blank" href="https://docs.python.org/2/library/xml.etree.elementtree.html">xml.etree.ElementTree</a> â€” The ElementTree XML API</h2>
    <p>Integrated into Python 2.5, provides a more Pythonic API to the document, not tied to the DOM standard
    <p>Provides limited <a target="_blank" href="http://www.w3.org/TR/xpath/">XPath</a> support
    <p>xml.etree.cElementTree is a compatible C implementation

</section>

<section class="slide">
    <h2>Creating an ElementTree</h2>
    <p>Parse a file with xml.etree.ElementTree.parse
    <p>Parse an XML string with xml.etree.ElementTree.fromstring
    <p>Write out an ElementTree with xml.etree.ElementTree.write(f) # filename or file object
</section>

<section class="slide">
    <h2><a target="_blank" href="http://en.wikipedia.org/wiki/XML_namespace">XML Namespaces</a></h2>
    <p>A W3C specification for uniquely identifying elements and attributes in an XML document
    <p>Multiple namespaces can be included in one document
    <p>Namespace names are URIs, strings chosen for their uniqueness property. Nothing is implied about the data behind the URI.
    <p>XML namespace definitions are added to an element, and apply to all child elements. Thus they are usually applied to the root element.  For instance, in our sample data the root element is:
<pre><code>
&lt;mediawiki xmlns="http://www.mediawiki.org/xml/export-0.8/" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://www.mediawiki.org/xml/export-0.8/ http://www.mediawiki.org/xml/export-0.8.xsd" version="0.8" xml:lang="en" &gt;
</code></pre>
    <p>The namespace of an element is indicated by adding prefix: to the element, e.g.
<pre><code>
&lt;html:p&gt;explicit html p tag&lt;/html:p &gt;
</code></pre>
</section>

<section class="slide">
    <h2><a target="_blank" href="http://effbot.org/zone/element-namespaces.htm">Namespaces in ElementTree</a></h2>

    <p>In an Element tree, qualified names are stored fully qualified in "Clark's notation", which is a single string of the form <code>{uri}local</code>, e.g. <code>{http://www.mediawiki.org/xml/export-0.8/}page</code>
    <p>When locating elements in a namespaced document, either pass the fully qualified name in the form above to find/findall/iterfind, or add the namespaces kwarg.  e.g.

<pre><code>
namespaces = {'xmlns': 'http://www.mediawiki.org/xml/export-0.8/'}
for title in root.findall('xmlns:page/xmlns:title', namespaces=namespaces):
</code></pre>

</section>

<section class="slide">
    <h2>wikipedia-elementtree.py</h2>
    <p>examples/wikipedia-elementtree.py logs the content of every &lt;title&gt; tag it encounters
    <p>Try running this to make sure it works
    <p class="slide">Now it's your turn, do the same author counting as with SAX, but this time use ElementTree.
        <ul class="slide">
            <li>The data consists of &lt;page&gt; elements for each page.
            <li>The current revision's author is stored as page/revision/contributor/username.
            <li>Modify wikipedia-elementtree.py to determine the username of the author with the most contributions in this data
        </ul>
    </p>
</section>

<section class="slide">
    <h2><a target="_blank" href="http://lxml.de/">lxml</a></h2>
    <p>lxml is Python binding for the C libraries libxml2 and libxslt
    <p>Does not ship with Python
    <p>provides an interface similar to ElementTree</p>
    <p>provides a SAX compliant API
    <p>has a focus on performance
</section>

<section class="slide">
    <h1>Questions?</h1>
</section>

    <!-- End slides. -->

    <!-- Begin extension snippets. Add or remove as needed. -->

    <!-- deck.navigation snippet -->
    <div aria-role="navigation">
      <a href="#" class="deck-prev-link" title="Previous">&#8592;</a>
      <a href="#" class="deck-next-link" title="Next">&#8594;</a>
    </div>

    <!-- deck.status snippet -->
    <p class="deck-status" aria-role="status">
      <span class="deck-status-current"></span>
      /
      <span class="deck-status-total"></span>
    </p>

    <!-- deck.goto snippet -->
    <form action="." method="get" class="goto-form">
      <label for="goto-slide">Go to slide:</label>
      <input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
      <datalist id="goto-datalist"></datalist>
      <input type="submit" value="Go">
    </form>

    <!-- End extension snippets. -->
  </div>

<!-- Required JS files. -->
<script src="jquery.min.js"></script>
<script src="core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="extensions/menu/deck.menu.js"></script>
<script src="extensions/goto/deck.goto.js"></script>
<script src="extensions/status/deck.status.js"></script>
<script src="extensions/navigation/deck.navigation.js"></script>
<script src="extensions/scale/deck.scale.js"></script>

<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
  $(function() {
    $.deck('.slide');
  });
</script>
</body>
</html>
